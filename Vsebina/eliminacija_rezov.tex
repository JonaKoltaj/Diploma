Poslednje pravilo, ki ga je potrebno vpeljati, je \emph{pravilo reza}. To pravilo obstaja tudi v običajnem sekventnem računu in formalizira koncept dokazovanja s pomočjo leme.

\begin{definicija}
	\emph{Pravilo reza} pravi, da če znamo pod določenimi predpostavkami dokazati formulo $A$, potem pa iz te formule dokažemo nekaj drugega, lahko $A$ enostavno režemo iz procesa.
	\begin{prooftree}
        \AxiomC{$\Gamma \Rightarrow A,\Delta$}
        \AxiomC{$\Gamma',A \Rightarrow \Delta'$}
        \pravilo{Rez}
        \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
	\end{prooftree}
\end{definicija}

\begin{opomba}
	Vsa dosedanja pravila v linearni logiki so bila na nek način deterministična. Če smo imeli v sekventu določen veznik, smo lahko uporabili pravilo vpeljave tega veznika, če pa v sekvetnu ni nastopal, tega nismo mogli narediti. Pravilo reza pa je v tem smislu drugačno, saj lahko drevo izpeljave poljubno razvejamo z novimi ,,vrinjenimi'' sekventi.
\end{opomba}
Preden smo v naš sekventni račun vpeljali pravilo reza, je bilo torej dokaj enostavno videti, če sekvent ne velja. Oglejmo si na primer iz podpoglavja \ref{ill}, kjer trdimo, da pricip izključene tretje možnosti ne velja za veznik $\sqcup$, tudi pri klasični linearni logiki.
\begin{center}
    \begin{bprooftree}
        \AxiomC{$\Rightarrow A$}
        \pravilo{R$\sqcup$}
        \UnaryInfC{$\Rightarrow A \sqcup (\negacija A)$}
    \end{bprooftree}
    \begin{bprooftree}
        \AxiomC{$\Rightarrow \negacija A$}
        \pravilo{R$\sqcup$}
        \UnaryInfC{$\Rightarrow A \sqcup (\negacija A)$}
    \end{bprooftree}
\end{center}
Ko dokazujemo sekvent $\Rightarrow A \sqcup (\negacija A)$ brez uporabe pravila reza, imamo na voljo le desno pravilo vpeljave veznika $\sqcup$ in nič drugega. Edina dva možna koraka sta torej prikazana zgoraj, sekvent $\Rightarrow A$ ali $\Rightarrow \negacija A$ pa ne bo veljal za poljubno formulo $A$, torej lahko trdimo, da sekvent, ki ga želimo dokazati, ne velja.

Če pa dopustimo uporabo pravila reza, lahko drevo neskončno razvejamo z vrivanjem poljubnih formul, na primer:
\begin{prooftree}
	\AxiomC{.}
	\noLine
	\UnaryInfC{.}
	\noLine
	\UnaryInfC{.}
	\noLine
	\UnaryInfC{$\Rightarrow B$}

	\AxiomC{.}
	\noLine
	\UnaryInfC{.}
	\noLine
	\UnaryInfC{.}
	\noLine
	\UnaryInfC{$B \Rightarrow A \sqcup (\negacija A)$}

	\pravilo{Rez}
	\BinaryInfC{$\Rightarrow A \sqcup (\negacija A)$}
\end{prooftree}
Drevo izpeljave se lahko razvejuje v neskončnost, zato ne moremo nikoli z gotovostjo trditi, da sekventa ne moremo izpeljati. A če pravilo reza res interpretiramo kot dokaz z uporabo leme, bi bilo smiselno, da če sekventa ne moremo dokazati brez uporabe rezov, ga tudi z rezi ne moremo dokazati. Tu nastopi naslednji izrek.

\begin{izrek}[Izrek o eliminaciji rezov] \label{izrek}
    Vsak sekvent, dokazan z uporabo reza, lahko dokažemo tudi brez uporabe reza.
\end{izrek}

\begin{posledica} %lah pises se o gentzenu etc
    Problem, opisan zgoraj, se torej ne pojavi. Ker sekventa brez reza ne moremo dokazati, ga tudi z rezom ne moremo, ne glede na to, kako razvejamo drevo izpeljave. Izrek nam torej zagotavlja konsistentnost sistema dokazovanja.
\end{posledica}

\subsection{Potrebne definicije} \label{defs}

Dokaz zgornjega izreka poteka z dvojno indukcijo, zunanjo na velikosti dreves izpeljave nad rezom, notranjo pa na kompleksnosti formule, ki jo režemo. Eden izmed načinov kako to izvesti je, da drevesom izpeljave pripišemo ,,višino'', formulam pa ,,rang'', dokaz pa potem poteka z dvojno naravno indukcijo na dani višini ter rangu. Tak način je malce zamuden, saj potrebuje dve novi in nekoliko zahtevni definiciji, poleg tega pa je že sama definicija formule -- in kot bomo videli definicija drevesa izpeljave -- induktivna, kot navedeno v definiciji \ref{formula}, kar se lepo ponuja \emph{strukturni indukciji}.

\begin{definicija}
    Kot pove že ime, \emph{strukturna indukcija} temelji na strukturi objekta, na katerem delamo indukcijo. Če želimo torej dokazati, da trditev $P$ velja za poljubno formulo, so baza indukcije $P(A)$, kjer je $A$ neka \emph{osnovna formula} ter $P(\enota),P(\nicla),P(\top)$ in $P(\bot)$. Indukcijska predpostavka trdi, da za poljubni formuli $B$ in $C$ velja $P(B)$ in $P(C)$, korak indukcije pa nato pove, da velja $P(B \star C),P(B + C),P(B \sqcap C),P(B \sqcup C),P(B \multimap C),P(\negacija B),P(\forall x B),P(\exists x B),P(!B)$ ter $P(?B)$. Če so vezniki, ki jih uporabljamo drugačni, je seveda tudi korak indukcije drugačen.
\end{definicija}

Kot smo zgoraj omenili, je potrebna tudi strukturna indukcija na drevesu izpeljave nad rezom, zato bolj formalno definirajmo drevo izpeljave. Definicija je, tako kot definicija formule, induktivna.

\begin{definicija}
    \emph{Drevo izpeljave} je -- kot katerokoli drevo -- sestavljeno iz \emph{vozlišča} in poljubnega števila poddreves, ki pa se končajo z \emph{listi}. V tem primeru je list pravilo aksioma, vozlišče pa je katerokoli pravilo. Drevo izpeljave je torej lahko v naslednjih dveh oblikah, za poljubna poddrevesa $\mathcal{D}_0,\mathcal{D}_1,\dots,\mathcal{D}_n$ in sklep $\mathcal{S}$.
    \begin{center}
        \begin{bprooftree}
            \AxiomC{}
            \pravilo{Ax}
            \UnaryInfC{$A \Rightarrow A$}
        \end{bprooftree}
        \qquad
        \begin{bprooftree}
            \AxiomC{$\mathcal{D}_0$}
            \AxiomC{$\mathcal{D}_1$}
            \AxiomC{$\dots$}
            \AxiomC{$\mathcal{D}_n$}
            \pravilo{Pravilo}
            \QuaternaryInfC{$\mathcal{S}$}
        \end{bprooftree}
    \end{center}
\end{definicija}

\begin{definicija}
    Strukturna indukcija na drevesih izpeljave bo potekala podobno kot strukturna indukcija na formulah, kjer tokrat za bazo indukcije vzamemo da trditev, ki jo želimo dokazati, velja za list drevesa, indukcijski korak pa pomeni, da če trditev velja za vsa poddrevesa, velja tudi za drevo, zgrajeno iz teh poddreves.
\end{definicija}

Še ena potrebna definicija, preden začnemo z dokazom izreka o eliminaciji rezov, je pojem glavnega reza.

\begin{definicija} \label{gl rez}
    Če je bila rezana formula ravnokar vpeljana v obeh poddrevesih nad pravilom reza, to imenujemo \emph{glavni rez}.
\end{definicija}

\begin{primer} \label{gl rez in}
    Glavni rez za formulo $A \sqcap B$.
    \begin{prooftree}
        \AxiomC{$\Gamma,A \Rightarrow \Delta$}
        \levopravilo{L$\sqcap$}
        \UnaryInfC{$\Gamma,A \sqcap B \Rightarrow \Delta$}

        \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
        \AxiomC{$\Gamma' \Rightarrow B,\Delta'$}
        \pravilo{R$\sqcap$}
        \BinaryInfC{$\Gamma' \Rightarrow A \sqcap B,\Delta'$}

        \pravilo{Rez}
        \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
    \end{prooftree}
\end{primer}

\subsection{Dokaz izreka o eliminaciji rezov}

Razlog, da izrek \ref{izrek} imenujemo izrek o \emph{eliminaciji rezov}, leži v tem, da dokaz poteka s postopno eliminacijo rezov iz poljubnega drevesa izpeljave, dokler na koncu ne dobimo drevesa izpeljave brez kakeršnegakoli pravila reza. Kot smo omenili na začetku podpoglavja \ref{defs}, dokaz poteka z dvojno indukcijo. Zunanja indukcija, je strukturna indukcija na drevesoma izpeljave nad rezom, notranja pa je strukturna indukcija na rezani formuli. Označimo z $\mathcal{D}_0$ ter $\mathcal{D}_1$ drevesi izpeljave nad rezom, torej:
\begin{prooftree}
    \AxiomC{$\mathcal{D}_0$}
    \AxiomC{$\mathcal{D}_1$}
    \pravilo{Rez}
    \BinaryInfC{$\mathcal{S}$}
\end{prooftree}

Začnimo z indukcijskim korakom. Predpostavljamo torej, da iz poddreves $\mathcal{D}_0$ in $\mathcal{D}_1$ znamo eliminirati reze. Da se izognemo problemu, kjer je bilo na primer zadnje pravilo v $\mathcal{D}_0$ ali $\mathcal{D}_1$ rez, predpostavimo, da smo reze tudi že eliminirali iz poddreves. Sedaj dokazujemo, da lahko zgornje drevo izpeljave preobrazimo v drevo izpeljave, kjer se rez pojavi višje v drevesu, torej v poddrevesu tega drevesa. To ustreza indukcijski predpostavki, zato je korak indukcije opravljen.

Znotraj tega koraka, pa seveda delamo tudi indukcijo na strukturi formule. Če torej zgornjega drevesa izpeljave ne uspemo prevesti na drevo, kjer se pravilo reza sedaj pojavi višje, ga lahko prevedemo na rez, ki reže podformulo prvotne formule. Baza notranje indukcije je, da pravilo reza, ki reže osnovno formulo, res prestavimo višje.

\begin{opomba}
    Zgoraj opisano indukcijo si lahko predstavljamo kot algoritem, ki sproti eliminira reze iz drevesa izpeljave. Začnemo z poddrevesom, ki kot zadnje pravilo uporabi rez, v nobenem izmed poddreves pa reza ne uporablja več, torej začnemo z ,,najvišjim'' rezom. Če je takih poddreves več, si arbitrarno izberemo enega izmed njih. V tem poddrevesu postopoma potiskamo rez višje ali pa vsaj znižujemo njegovo kompleksnost, dokler reza ne eliminiramo iz poddrevesa. To ponovimo za vsak rez v drevesu izpeljave. Ker je slednje končno, se proces ustavi in drevo izpeljave ne vključuje več rezov.
\end{opomba}

Vrnimo se h koraku indukcije. Pri obravnavi eliminacije reza je potrebno ločiti, ali je rez, ki ga eliminiramo \emph{glaven}, kot ga opiše definicija \ref{gl rez}, ali pa ni.

\subsubsection{Eliminacija glavnega reza}

Kaj pomeni, da je rez glaven, je odvisno od vsake rezane formule posebej. Eliminacijo glavnega reza je torej potrebno ločiti na vse možne veznike. Začnimo kar z veznikom $\sqcap$, ki smo ga že uporabili v primeru \ref{gl rez in}.
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \levopravilo{L$\sqcap$}
    \UnaryInfC{$\Gamma,A \sqcap B \Rightarrow \Delta$}

    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \AxiomC{$\Gamma' \Rightarrow B,\Delta'$}
    \pravilo{R$\sqcap$}
    \BinaryInfC{$\Gamma' \Rightarrow A \sqcap B,\Delta'$}

    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}
\begin{center}
    $\downarrow$
\end{center}
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}
Izpeljava pred puščico in po njej je enaka, saj iz istih poddreves dokažemo isti sekvent. Tako smo lahko pravilo, ki reže $A \sqcap B$ zamenjali s pravilom, ki reže le $A$, zato je korak indukcije opravljen. Podobno lahko naredimo za glavni rez $A \star B$.
\begin{prooftree}
    \AxiomC{$\Gamma,A,B \Rightarrow \Delta$}
    \levopravilo{L$\star$}
    \UnaryInfC{$\Gamma,A \star B \Rightarrow \Delta$}

    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \AxiomC{$\Gamma'' \Rightarrow B,\Delta''$}
    \pravilo{R$\star$}
    \BinaryInfC{$\Gamma',\Gamma'' \Rightarrow A \star B,\Delta',\Delta''$}

    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
\begin{center}
    $\downarrow$
\end{center}
\begin{prooftree}
    \AxiomC{$\Gamma,A,B \Rightarrow \Delta$}
    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \levopravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',B \Rightarrow \Delta,\Delta'$}

    \AxiomC{$\Gamma'' \Rightarrow B,\Delta''$}
    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
Tokrat smo sicer prvotni rez prevedli na dva, a oba novonastala reza režeta podformuli, zato zopet zadostimo indukcijski predpostavki. Zelo podobno kot zgornje dva primera izvedemo korak indukcije za $A \sqcup B$ ter $A+B$.
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma,B \Rightarrow \Delta$}
    \levopravilo{L$\sqcup$}
    \BinaryInfC{$\Gamma,A \sqcup B \Rightarrow \Delta$}

    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \pravilo{R$\sqcup$}
    \UnaryInfC{$\Gamma' \Rightarrow A \sqcup B,\Delta'$}

    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}
\begin{center}
    $\downarrow$
\end{center}
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma' \Rightarrow A,\Delta'$}
    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}
Kot vidimo je zgornji korak indukcije popolnoma simetričen koraku indukcije za $A \sqcap B$, saj sta tudi veznika sama popolnoma simetrična. Prav tako je korak indukcije za $A+B$ popolnoma simetričen koraku indukcije za $A \star B$.
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma',B \Rightarrow \Delta'$}
    \levopravilo{L+}
    \BinaryInfC{$\Gamma,\Gamma',A + B \Rightarrow \Delta,\Delta'$}

    \AxiomC{$\Gamma'' \Rightarrow A,B,\Delta''$}
    \pravilo{R+}
    \UnaryInfC{$\Gamma'' \Rightarrow A + B,\Delta''$}

    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
\begin{center}
    $\downarrow$
\end{center}
\begin{prooftree}
    \AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma'' \Rightarrow A,B,\Delta''$}
    \levopravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma'' \Rightarrow B,\Delta,\Delta''$}

    \AxiomC{$\Gamma',B \Rightarrow \Delta'$}
    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
Naslednja eliminacija glavnega reza, ki jo je potrebno obravnavati je eliminacija glavnega reza implikacije. Zopet se rez prevede na dva manj kompleksna reza.
\begin{prooftree}
	\AxiomC{$\Gamma,A \Rightarrow \Delta$}
    \AxiomC{$\Gamma',B \Rightarrow \Delta'$}
    \levopravilo{L$\multimap$}
    \BinaryInfC{$\Gamma,\Gamma',A \multimap B \Rightarrow \Delta,\Delta'$}

    \AxiomC{$\Gamma'',A \Rightarrow B,\Delta''$}
    \pravilo{R$\multimap$}
    \UnaryInfC{$\Gamma'' \Rightarrow A \multimap B,\Delta''$}

    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
\begin{center}
    $\downarrow$
\end{center}
\begin{prooftree}
	\AxiomC{$\Gamma,A \Rightarrow \Delta$}
	\AxiomC{$\Gamma'',A \Rightarrow B,\Delta''$}
    \levopravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma'' \Rightarrow B,\Delta,\Delta''$}

    \AxiomC{$\Gamma',B \Rightarrow \Delta'$}
    \pravilo{Rez}
    \BinaryInfC{$\Gamma,\Gamma',\Gamma'' \Rightarrow \Delta,\Delta',\Delta''$}
\end{prooftree}
Poslednji izmed veznikov, ki ga potrebujemo obravnavati je negacija.
\begin{prooftree}
    \AxiomC{$\Gamma \Rightarrow A,\Delta$}
	\levopravilo{L$\negacija$}
	\UnaryInfC{$\Gamma,\negacija A \Rightarrow \Delta$}

	\AxiomC{$\Gamma',A \Rightarrow \Delta'$}
	\pravilo{R$\negacija$}
	\UnaryInfC{$\Gamma' \Rightarrow \negacija A,\Delta'$}

	\pravilo{Rez}
	\BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}
\begin{center}
	$\downarrow$
\end{center}
\begin{prooftree}
    \AxiomC{$\Gamma \Rightarrow A,\Delta$}
	\AxiomC{$\Gamma',A \Rightarrow \Delta'$}
	\pravilo{Rez}
	\BinaryInfC{$\Gamma,\Gamma' \Rightarrow \Delta,\Delta'$}
\end{prooftree}

% Dej bazo na konc, i think da leps pase
% Baza indukcije na $\mathcal{D}_0$ in $\mathcal{D}_1$ pomeni, da je vsaj eden izmed $\mathcal{D}_0$ ter $\mathcal{D}_1$ list, torej pravilo aksioma, ter da tisto poddrevo, ki ni list, ne vsebuje pravila rez. Potrebno je dokazati, da lahko take vrste drevo izpeljave preobrazimo v drevo izpeljave brez rezov. Oglejmo si torej primer, ko je $\mathcal{D}_0$ list, $\mathcal{D}_1$ pa ni. Obratno je seveda simetrično.
%
% \begin{center}
%     \begin{bprooftree}
%         \AxiomC{}
%         \pravilo{Ax}
%         \UnaryInfC{$A \Rightarrow A$}
%
%         \AxiomC{$\Gamma,A \Rightarrow \Delta$}
%         \pravilo{Rez}
%         \BinaryInfC{$\Gamma,A \Rightarrow \Delta$}
%     \end{bprooftree}\qquad
%     $\rightarrow$ \qquad
%     \begin{bprooftree}
%         \AxiomC{$\Gamma,A \Rightarrow \Delta$}
%     \end{bprooftree}
% \end{center}
% Kot lahko vidimo,

% TODO baza notranje indukcije (aka osnovno formulo lah gor fuknemo, figure it out)
